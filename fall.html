<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>iPhone 横屏 Plinko</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Segoe UI", "PingFang SC", sans-serif;

            /* ★ 可爱渐变背景（非黑灰） */
            background: linear-gradient(135deg, #ffb3d9 0%, #a8c7ff 100%);
        }

        canvas { display: block; }

        /* ★ 控件毛玻璃面板 */
        #controls {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            display: flex;
            gap: 12px;
            align-items: center;

            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        #controls label {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        #controls input {
            width: 60px;
            padding: 6px;
            border-radius: 8px;
            border: none;
            text-align: center;
            font-size: 16px;
        }

        /* ★ 可爱按钮样式 */
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 14px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: #fff;
            transition: 0.2s;
            box-shadow: 0 3px 8px rgba(0,0,0,0.18);
        }

        #dropBall {
            background: #ff9eb5;
        }
        #dropBall:hover { background: #ff85a3; }

        #resetBalls {
            background: #ffbf80;
        }
        #resetBalls:hover { background: #ffac57; }

        /* ★ 顶部提示文字 */
        #result {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 26px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="result"></div>

<div id="controls">
    <label>目标: <input id="targetNum" type="number" value="2"></label>
    <button id="dropBall">掉落小球</button>
    <button id="resetBalls">重新开始</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js/build/matter.min.js"></script>
<script>

    const {Engine, Render, Runner, Bodies, Composite, Events, Body} = Matter;

    const engine = Engine.create();
    const world = engine.world;

    let width = window.innerWidth;
    let height = window.innerHeight;

    window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;
        render.canvas.width = width;
        render.canvas.height = height;
    });

    const render = Render.create({
        element: document.body,
        engine,
        options: {
            width,
            height,
            wireframes:false,

            /* ★ 渐变背景由 body 控制，canvas 背景透明 */
            background: "transparent"
        }
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);

    /* 边界 */
    const wallThickness = 20;
    Composite.add(world, [
        Bodies.rectangle(width/2, -wallThickness/2, width, wallThickness, {isStatic:true}),
        Bodies.rectangle(width/2, height+wallThickness/2, width, wallThickness, {isStatic:true}),
        Bodies.rectangle(-wallThickness/2, height/2, wallThickness, height, {isStatic:true}),
        Bodies.rectangle(width+wallThickness/2, height/2, wallThickness, height, {isStatic:true}),
    ]);

    /* 底部格子 */
    const slotsArr = [1,3,2,1,5,6,5,1,4,3,2,1];
    const slotCount = slotsArr.length;
    const slotWidth = width / slotCount;
    const slotHeight = height * 0.18;

    for (let i=0;i<slotCount;i++){
        const leftX = i*slotWidth;
        const rightX = (i+1)*slotWidth;
        const yTop = height - slotHeight;

        Composite.add(world, Bodies.rectangle(leftX, yTop+slotHeight/2, 3, slotHeight, {isStatic:true, render:{fillStyle:"#fff"}}));
        Composite.add(world, Bodies.rectangle(rightX, yTop+slotHeight/2, 3, slotHeight, {isStatic:true, render:{fillStyle:"#fff"}}));
        Composite.add(world, Bodies.rectangle(leftX+slotWidth/2, height, slotWidth, 3, {isStatic:true, render:{fillStyle:"#fff"}}));
    }

    /* 数字绘制 */
    const canvas = render.canvas;
    const ctx = canvas.getContext("2d");
    (function drawNums(){
        ctx.clearRect(0,0,width,height);
        Render.world(render);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `${Math.floor(slotHeight/2)}px Arial`;

        for(let i=0;i<slotCount;i++){
            ctx.fillText(slotsArr[i], i*slotWidth + slotWidth/2, height - slotHeight/2);
        }
        requestAnimationFrame(drawNums);
    })();

    /* 柱子网格（三角） */
    const rows = 7;
    const cols = 18;
    const spacingX = width / cols;
    const spacingY = (height - slotHeight - 100) / rows;
    const radius = 6;

    for(let r=0;r<rows;r++){
        const isOdd = r % 2 !== 0;
        const offset = isOdd ? spacingX/2 : 0;
        const colCount = isOdd ? cols - 1 : cols;

        for(let c=0;c<colCount;c++){
            Composite.add(world, Bodies.circle(
                c*spacingX + offset + spacingX/2,
                r*spacingY + 100,
                radius,
                {
                    isStatic:true,
                    render:{ fillStyle:"#ffffff88" }   // ★ 白色透明的小柱子
                }
            ));
        }
    }

    /* 小球管理 */
    let balls = [];

    function dropBall(targetNum){
        const arr = [];
        slotsArr.forEach((v,i)=>{ if(v===targetNum) arr.push(i) });
        if(arr.length === 0) return;

        const idx = arr[Math.floor(Math.random()*arr.length)];
        const targetX = idx*slotWidth + slotWidth/2;

        const startX = targetX + (Math.random()-0.5) * slotWidth * 1.5;

        const ball = Bodies.circle(startX, 50, 12, {
            restitution:0.6,
            friction:0.85,
            frictionAir:0.045,

            /* ★ 可爱渐变色小球 */
            render:{
                fillStyle: "url(#pinkBall)"
            }
        });

        ball.targetX = targetX;
        balls.push(ball);
        Composite.add(world, ball);
    }

    /* 重力引导 */
    Events.on(engine, "afterUpdate", ()=>{
        balls.forEach(ball=>{
            if(ball.position.y < height - slotHeight - 20){
                const dx = ball.targetX - ball.position.x;
                Body.applyForce(ball, ball.position, {x:dx*0.000002, y:0});
            }
            if(ball.position.y > height-slotHeight){
                Body.setVelocity(ball,{x:0,y:0});
            }
        });
    });

    /* 重新开始按钮 */
    document.getElementById("resetBalls").onclick = ()=>{
        balls.forEach(ball=> Composite.remove(world, ball));
        balls = [];
        document.getElementById("result").innerText = "";
    };

    document.getElementById("dropBall").onclick = ()=>{
        const t = Number(document.getElementById("targetNum").value);
        dropBall(t);
    };

</script>

</body>
</html>
