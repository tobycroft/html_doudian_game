<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>落地成盒模拟器</title>
    <style>
        :root {
            --accent1: #ff9eb5;
            --accent2: #ffbf80;
            --glass: rgba(255, 255, 255, 0.22);
        }

        html, body {
            height: 100%;
            margin: 0;
            white-space: nowrap;
        }

        body {
            font-family: "Segoe UI", "PingFang SC", system-ui, sans-serif;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #ffd6eb 0%, #cfe3ff 100%);
            -webkit-tap-highlight-color: transparent;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* top area */
        #topBar {
            position: absolute;
            top: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .group {
            padding: 4px;
            border-radius: 18px;
            display: flex;
            gap: 0;
            align-items: center;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
        }

        .label {
            color: #fff;
            font-weight: 700;
            font-size: 12px;
        }

        .btn {
            min-width: 36px;
            height: 36px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            background: transparent;
            color: #fff;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform .12s, box-shadow .12s, opacity .12s;
        }

        .btn.selected {
            background: linear-gradient(180deg, #fff 0%, #ffecef 100%);
            color: #ff5a8a;
            box-shadow: 0 6px 20px rgba(255, 90, 138, 0.18);
            transform: translateY(-2px);
        }

        /* controls */
        #controls {
            position: absolute;
            top: 4rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 190;
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px 14px;
            border-radius: 14px;
            background: var(--glass);
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        #controls label {
            color: #fff;
            font-weight: 700;
            margin-right: 6px;
        }

        #targetNum {
            width: 64px;
            padding: 6px 8px;
            border-radius: 10px;
            border: none;
            text-align: center;
            font-size: 16px;
        }

        button.uiBtn {
            padding: 8px 14px;
            border-radius: 12px;
            border: none;
            color: #fff;
            font-weight: 800;
            font-size: 15px;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.12);
            cursor: pointer;
        }

        #dropBall {
            background: linear-gradient(180deg, var(--accent1), #ff85a3);
        }

        #dropBall[disabled] {
            opacity: .56;
            cursor: not-allowed;
            filter: grayscale(.05);
        }

        #resetBalls {
            background: linear-gradient(180deg, var(--accent2), #ffac57);
        }

        /* result */
        #result {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 180;
            color: #fff;
            font-size: 20px;
            font-weight: 900;
            text-shadow: 0 3px 10px rgba(0, 0, 0, 0.22);
        }

        .hint {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            color: #8bc34a;
            font-weight: 700;
            z-index: 140;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
            padding: 6px 6px;
            border-radius: 0 0 12px 12px;
        }

    </style>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, orientation=landscape">
</head>
<body>

<!-- top: pack selector + packCount selector -->
<div id="topBar">
    <div class="group" id="packSelector" aria-label="pack selector">
        <span class="label">保底包数:</span>
        <button class="btn" data-pack="1">1</button>
        <button class="btn" data-pack="2">2</button>
        <button class="btn" data-pack="3">3</button>
        <button class="btn" data-pack="4">4</button>
    </div>

    <div class="group" id="countSelector" aria-label="ball count">
        <span class="label">推几手：</span>
        <button class="btn" data-count="1">1</button>
        <button class="btn" data-count="2">2</button>
        <button class="btn" data-count="3">3</button>
        <button class="btn" data-count="5">5</button>
    </div>

</div>
<div id="controls">
    <label style="color:#fff"></label>
    <button id="resetBalls" class="uiBtn">重开</button>
    <button id="dropBall" class="uiBtn" disabled>祝欧并掉落</button>
<!--    <button id="goFullScreen" class="uiBtn">-->
<!--        全屏并横屏-->
<!--    </button>-->
</div>
<!-- controls -->


<div id="result"></div>
<!--<div class="hint">弹簧柱模拟器-请横屏使用</div>-->

<script src="https://cdn.jsdelivr.net/npm/matter-js/build/matter.min.js"></script>
<script>

    (function () {
        const {Engine, Render, Runner, Bodies, Composite, Events, Body} = Matter;

        // UI elements
        const packSelector = document.getElementById('packSelector');
        const packButtons = Array.from(packSelector.querySelectorAll('.btn'));
        const countSelector = document.getElementById('countSelector');
        const countButtons = Array.from(countSelector.querySelectorAll('.btn'));
        const dropBtn = document.getElementById('dropBall');
        const resetBtn = document.getElementById('resetBalls');
        const resultDiv = document.getElementById('result');

        // state
        let pack = 2;         // default pack for API
        let packCount = 1;    // number of balls to drop at once (1,2,3,5)
        let slotsData = [];   // array from server (each item has num,is_lock,ratio,...)
        let staticBodies = []; // slot walls + bottoms
        let pegBodies = [];    // pegs
        let balls = [];        // active balls
        let slotCount = 0;
        let slotWidth = 0;
        let slotHeight = 0;
        let engine, render;


        // helper: update UI selection
        function updatePackUI() {
            packButtons.forEach(b => b.classList.toggle('selected', Number(b.dataset.pack) === pack));
        }

        function updateCountUI() {
            countButtons.forEach(b => b.classList.toggle('selected', Number(b.dataset.count) === packCount));
        }

        // init pack UI default
        pack = 2;
        packCount = 1;
        updatePackUI();
        updateCountUI();

        // attach events
        packButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                pack = Number(btn.dataset.pack);
                updatePackUI();
                // on pack change, we should refresh server data immediately (non-blocking)
                preloadSlots(true); // background refresh
            });
        });

        countButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                packCount = Number(btn.dataset.count);
                updateCountUI();
            });
        });

        // ---------------- Matter.js init ----------------
        engine = Engine.create();
        const world = engine.world;

        let width = window.innerWidth;
        let height = window.innerHeight;

        render = Render.create({
            element: document.body,
            engine,
            options: {width, height, wireframes: false, background: 'transparent'}
        });
        Render.run(render);
        Runner.run(Runner.create(), engine);

        // handle resize (simple)
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            render.canvas.width = width;
            render.canvas.height = height;
        });

        // add outer boundaries (static)
        const wallThickness = 30;
        Composite.add(world, [
            Bodies.rectangle(width / 2, -wallThickness / 2, width, wallThickness, {isStatic: true}),
            Bodies.rectangle(width / 2, height + wallThickness / 2, width, wallThickness, {isStatic: true}),
            Bodies.rectangle(-wallThickness / 2, height / 2, wallThickness, height, {isStatic: true}),
            Bodies.rectangle(width + wallThickness / 2, height / 2, wallThickness, height, {isStatic: true})
        ]);

        // overlay drawing of numbers
        const ctx = render.canvas.getContext('2d');
        (function drawLoop() {
            ctx.clearRect(0, 0, width, height);
            Render.world(render);

            // draw numbers inside slots
            if (slotCount > 0) {
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.max(14, Math.floor(slotHeight * 0.48));
                ctx.font = `${fontSize}px sans-serif`;
                for (let i = 0; i < slotCount; i++) {
                    const x = i * slotWidth + slotWidth / 2;
                    const y = height - slotHeight / 2;
                    ctx.fillText(String(slotsData[i].num), x, y);
                    if (Number(slotsData[i].is_lock) === 1) {
                        // small lock dot to indicate locked
                        ctx.fillStyle = 'rgba(200,200,200,0.95)';
                        ctx.beginPath();
                        ctx.arc(x + slotWidth / 2 - 18, y - slotHeight / 2 + 16, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                    }
                }
            }

            requestAnimationFrame(drawLoop);
        })();

        // helper: clear static objects (slots + pegs)
        function clearStatics() {
            staticBodies.forEach(b => Composite.remove(world, b));
            pegBodies.forEach(b => Composite.remove(world, b));
            staticBodies = [];
            pegBodies = [];
        }

        // build layout from slotsData (simple version)
        function buildLayout() {
            clearStatics();

            /** ---------------- Slots （底部格子） ---------------- **/
            slotCount = slotsData.length || 0;
            slotWidth = width / Math.max(slotCount, 1);
            slotHeight = height * 0.18;

            for (let i = 0; i < slotCount; i++) {
                const leftX = i * slotWidth;
                const rightX = (i + 1) * slotWidth;
                const yTop = height - slotHeight;

                const leftWall = Bodies.rectangle(
                    leftX,
                    yTop + slotHeight / 2,
                    2, slotHeight,
                    {isStatic: true, render: {fillStyle: '#ffffffcc'}}
                );

                const rightWall = Bodies.rectangle(
                    rightX,
                    yTop + slotHeight / 2,
                    2, slotHeight,
                    {isStatic: true, render: {fillStyle: '#ffffffcc'}}
                );

                const bottom = Bodies.rectangle(
                    leftX + slotWidth / 2,
                    height,
                    slotWidth,
                    2,
                    {isStatic: true, render: {fillStyle: '#ffffffcc'}}
                );

                Composite.add(world, [leftWall, rightWall, bottom]);
                staticBodies.push(leftWall, rightWall, bottom);
            }

            /** ---------------- Pegs（柱子/钉子） ---------------- **/
            const rows = 15;
            const cols = 8;
            const spacingX = width / cols-2 ;
            const spacingY = (height - slotHeight - 100) / rows - 3;
            const radius = 6;

            for (let r = 0; r < rows; r++) {
                const isOdd = r % 2 !== 0;
                const offset = isOdd ? spacingX / 2 : 0;
                const count = isOdd ? cols - 1 : cols;

                for (let c = 0; c < count; c++) {
                    const peg = Bodies.circle(
                        c * spacingX + offset + spacingX / 2 +10,
                        r * spacingY + 130,
                        radius,
                        {isStatic: true, render: {fillStyle: "#ffffff88"}}
                    );
                    Composite.add(world, peg);
                    pegBodies.push(peg);
                }
            }
        }


        // fetch slots from server (returns data array or throws)
        async function fetchSlots(packValue) {
            const url = 'https://upload.tuuz.cc:444/v2/doudian/game/fall';
            const fd = new FormData();
            fd.append('pack', String(packValue));
            const resp = await fetch(url, {method: 'POST', body: fd});
            if (!resp.ok) throw new Error('network ' + resp.status);
            const json = await resp.json();
            if (!json || !Array.isArray(json.data)) throw new Error('invalid data');
            return json.data;
        }

        // weighted random by ratio; if all weights zero -> uniform
        function weightedIndexByRatio(data) {
            const weights = data.map(it => {
                const r = Number(it.ratio);
                return (isFinite(r) && r >= 0) ? r : 0;
            });
            const sum = weights.reduce((s, a) => s + a, 0);
            if (sum <= 0) {
                return Math.floor(Math.random() * data.length);
            }
            let rnd = Math.random() * sum;
            for (let i = 0; i < weights.length; i++) {
                rnd -= weights[i];
                if (rnd <= 0) return i;
            }
            return weights.length - 1;
        }

        // choose target index per rules:
        // if any is_lock == 1 -> pick random among them
        // else pick weighted by ratio across all indices
        function chooseTargetIndexFromData() {
            if (!slotsData || slotsData.length === 0) return -1;
            const locked = [];
            for (let i = 0; i < slotsData.length; i++) {
                if (Number(slotsData[i].is_lock) === 1) locked.push(i);
            }
            if (locked.length > 0) return locked[Math.floor(Math.random() * locked.length)];
            return weightedIndexByRatio(slotsData);
        }

        // spawn a ball near target index (randomized startX), ball.targetX used for micro-guidance
        function spawnBallForIndex(idx) {
            if (idx < 0 || idx >= slotCount) return;
            const targetX = idx * slotWidth + slotWidth / 2;
            const offsetRange = slotWidth * 0.6;
            const startX = targetX + (Math.random() - 0.5) * offsetRange;
            const ballRadius = Math.max(12, Math.min(14, Math.round(slotWidth * 0.11)));
            const ball = Bodies.circle(startX, 50, ballRadius, {
                restitution: 0.5,
                friction: 0.25,
                frictionStatic: 0.25,
                frictionAir: 0.05,
                density: 1,
                render: {fillStyle: '#ff6fa4'}
            });
            ball.targetX = targetX;
            balls.push(ball);
            Composite.add(world, ball);
        }

        // micro-guidance & landing detection
        Events.on(engine, 'afterUpdate', () => {
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                if (!ball) continue;
                // micro force while above slot area
                if (ball.position.y < height - slotHeight - 12) {
                    const dx = ball.targetX - ball.position.x;
                    const heightFactor = Math.max(0.08, (ball.position.y / (height - slotHeight)));
                    Body.applyForce(ball, ball.position, {x: dx * 0.008 * heightFactor, y: 0.1});
                }
                // landing: if inside bottom region, zero velocity and snap
                if (ball.position.y > height - slotHeight - 6) {
                    Body.setVelocity(ball, {x: 0, y: 0});
                    Body.setAngularVelocity(ball, 0);
                    const idx = Math.max(0, Math.min(slotCount - 1, Math.floor(ball.position.x / slotWidth)));
                    resultDiv.textContent = `小球落在数字: ${slotsData[idx].num} （格子 ${idx}）`;
                }
            }
            // enable/disable dropBtn: allow one round at a time (no new drop while existing balls are moving)
            const anyMoving = balls.some(b => b && (Math.abs(b.velocity.x) > 0.2 || Math.abs(b.velocity.y) > 0.2));
            // only enable when data loaded and no moving balls
            dropBtn.disabled = (slotsData.length === 0) || anyMoving;
        });

        // preload on page load: fetch once and build layout; during this dropBtn is disabled
        let initialLoading = true;

        async function preloadSlots(backgroundOnly = false) {
            // backgroundOnly true = caller initiated refresh but UI may already be interactive
            try {
                if (!backgroundOnly) {
                    dropBtn.disabled = true;
                    resultDiv.textContent = '加载中...';
                }
                const data = await fetchSlots(pack);
                // normalize
                slotsData = data.map(d => ({
                    num: ('num' in d) ? d.num : (d.value ?? 0),
                    is_lock: ('is_lock' in d) ? Number(d.is_lock) : 0,
                    ratio: ('ratio' in d) ? Number(d.ratio) : 0,
                    raw: d
                }));
                buildLayout();
                resultDiv.textContent = '';
            } catch (err) {
                console.error('预加载失败', err);
                if (!backgroundOnly) resultDiv.textContent = '预加载失败，请稍后重试';
            } finally {
                initialLoading = false;
                // enable drop if no balls moving and slotsData exists
                const anyMoving = balls.some(b => b && (Math.abs(b.velocity.x) > 0.2 || Math.abs(b.velocity.y) > 0.2));
                dropBtn.disabled = (slotsData.length === 0) || anyMoving;
            }
        }

        // main: when clicking drop -> choose target index (per rules) then spawn packCount balls
        // After spawn, do a background refresh of slotsData for next round
        async function onDropClicked() {
            if (slotsData.length === 0) return;
            // prevent if balls are moving (guard)
            const anyMoving = balls.some(b => b && (Math.abs(b.velocity.x) > 0.2 || Math.abs(b.velocity.y) > 0.2));
            if (anyMoving) return;

            // Choose target(s):
            // If there are locked slots, each spawned ball will choose randomly among locked ones (consistent with spec).
            // Otherwise, use weighted selection for each ball independently.
            for (let i = 0; i < packCount; i++) {
                let chosenIdx;
                const lockedIdxs = slotsData.map((it, idx) => Number(it.is_lock) === 1 ? idx : -1).filter(x => x >= 0);
                if (lockedIdxs.length > 0) {
                    chosenIdx = lockedIdxs[Math.floor(Math.random() * lockedIdxs.length)];
                } else {
                    // weighted by ratio across indices
                    chosenIdx = weightedIndexByRatio(slotsData);
                }
                console.log('预计落点 index =', chosenIdx, '对应槽位数据:', slotsData[chosenIdx]["num"]);
                spawnBallForIndex(chosenIdx);
            }


        }

        // reset: remove balls (keep layout)
        resetBtn.addEventListener('click', () => {
            balls.forEach(b => Composite.remove(world, b));
            balls = [];
            resultDiv.textContent = '';
            // re-enable drop if slotsData loaded
            dropBtn.disabled = (slotsData.length === 0);
            // Immediately kick off background fetch to refresh slots for next round (non-blocking)
            (async () => {
                try {
                    const data = await fetchSlots(pack);
                    slotsData = data.map(d => ({
                        num: ('num' in d) ? d.num : (d.value ?? 0),
                        is_lock: ('is_lock' in d) ? Number(d.is_lock) : 0,
                        ratio: ('ratio' in d) ? Number(d.ratio) : 0,
                        raw: d
                    }));
                    buildLayout();
                } catch (err) {
                    console.error('后台刷新失败', err);
                    // keep current slotsData if refresh fails
                }
            })();
        });

        dropBtn.addEventListener('click', onDropClicked);

        // initial preload
        preloadSlots(false);

    })();
    document.getElementById('goFullScreen').addEventListener('click', async () => {
        const elem = document.documentElement;

        // 请求全屏
        if (elem.requestFullscreen) {
            try {
                await elem.requestFullscreen();
            } catch (e) {
                console.warn('全屏失败:', e);
            }
        } else if (elem.webkitRequestFullscreen) {
            await elem.webkitRequestFullscreen(); // Safari
        }

        // 尝试锁定横屏（移动端支持）
        if (screen.orientation && screen.orientation.lock) {
            try {
                await screen.orientation.lock('landscape');
            } catch (e) {
                console.warn('横屏锁定失败:', e);
            }
        } else if (screen.lockOrientation) {
            // 老式 API
            screen.lockOrientation('landscape');
        }
    });
</script>

</body>
</html>
