<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>抽卡小游戏</title>

    <style>
        body {
            margin: 0;
            padding: 12px;
            font-family: system-ui, -apple-system;
            background: #f5f6fa;
        }

        .pack-container {
            backdrop-filter: blur(12px);
            background: rgba(255,255,255,0.65);
            border-radius: 16px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .pack-container strong {
            display: block;
            margin-bottom: 8px;
        }

        .pack-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .pack-buttons button {
            font-size: 20px;
            padding: 10px 16px;
            border-radius: 10px;
            border: none;
            background: #ddd;
        }

        .pack-buttons button.active {
            background: #4a90e2;
            color: #fff;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 16px 0;
        }

        .card {
            perspective: 900px;
        }

        .card-inner {
            position: relative;
            width: 100%;
            padding-top: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card.open .card-inner {
            transform: rotateY(180deg);
        }

        .face {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 34px;
            border-radius: 14px;
            backface-visibility: hidden;
        }

        .back {
            background: #888;
            color: #fff;
        }

        .front {
            background: #fff;
            border: 2px solid #4a90e2;
            transform: rotateY(180deg);
        }

        .card.selected .back {
            background: #ffd54f;
            color: #000;
        }

        .card.selected .front {
            background: #ffe08a;
        }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .actions button {
            font-size: 22px;
            padding: 14px;
            border-radius: 16px;
            border: none;
        }

        .confirm {
            background: #4a90e2;
            color: #fff;
        }

        .reset {
            background: #f5b7b1;
        }

        .result-box {
            margin-top: 12px;
            font-size: 18px;
        }
    </style>
</head>

<body>

<div class="pack-container">
    <strong>连包数量</strong>
    <div class="pack-buttons" id="packBtns"></div>
</div>

<div class="grid" id="grid"></div>

<div class="actions">
    <button class="confirm" onclick="confirmOpen()">确定并打开</button>
    <button class="reset" onclick="resetGame()">再抽一次</button>
</div>

<div class="result-box">
    上一次抽取结果：
    <span id="lastResult">无</span>
</div>

<script>
    /* ===== 配置 ===== */
    const API_URL = "https://upload.tuuz.cc:444/v2/doudian/game/fanka";

    /* ===== 状态 ===== */
    let packCount = 1;
    let selected = [];
    let opened = false;
    let lastResult = [];

    /* 默认池 */
    let NORMAL_POOL = [5,2,1,2,4,3,1,2,1];
    let HIT_CONF = {
        1:0.3,2:0.3,3:0.2,4:0.1,5:0.1,
        max:3,
        lock:1
    };

    /* ===== 初始化 ===== */
    initPackButtons();
    fetchRemote();

    /* ===== 包数按钮 ===== */
    function initPackButtons() {
        const box = document.getElementById("packBtns");
        [1,2,3,5].forEach(n => {
            const btn = document.createElement("button");
            btn.textContent = n;
            if (n === 1) btn.classList.add("active");

            btn.onclick = () => {
                packCount = n;
                document.querySelectorAll(".pack-buttons button")
                    .forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
            };
            box.appendChild(btn);
        });
    }

    /* ===== 构建卡片 ===== */
    function buildCards() {
        const grid = document.getElementById("grid");
        grid.innerHTML = "";
        selected = [];
        opened = false;

        NORMAL_POOL.forEach((v, i) => {
            const card = document.createElement("div");
            card.className = "card";
            card.innerHTML = `
            <div class="card-inner">
                <div class="face back">?</div>
                <div class="face front">${v}</div>
            </div>
        `;
            card.onclick = () => toggleSelect(card, i);
            grid.appendChild(card);
        });
    }

    /* ===== 选中逻辑 ===== */
    function toggleSelect(card, idx) {
        if (opened) return;

        if (selected.includes(idx)) {
            selected = selected.filter(i => i !== idx);
            card.classList.remove("selected");
        } else {
            if (selected.length >= packCount) return;
            selected.push(idx);
            card.classList.add("selected");
        }
    }

    /* ===== 权重随机 ===== */
    function weightedRand() {
        let pool = [];
        Object.entries(HIT_CONF).forEach(([k,v])=>{
            if (+k > 0 && typeof v === "number") {
                for (let i=0;i<v*100;i++) pool.push(+k);
            }
        });
        let r = pool[Math.floor(Math.random()*pool.length)] || 0;
        if (HIT_CONF.lock && r > HIT_CONF.max) return HIT_CONF.max;
        return r;
    }

    /* ===== 确认并打开 ===== */
    function confirmOpen() {
        if (opened) return;
        opened = true;

        document.getElementById("lastResult").textContent =
            lastResult.length ? lastResult.join(", ") : "无";

        lastResult = [];

        // 获取所有卡片元素
        const cards = document.querySelectorAll(".card");

        // 生成选中卡片的随机结果
        const selectedResults = [];
        // 跟踪选中卡片中各数字的出现次数
        const selectedCounts = {3: 0, 4: 0, 5: 0};

        selected.forEach(idx => {
            const r = weightedRand();
            selectedResults.push({ idx, value: r });
            lastResult.push(r);
            // 统计选中卡片中3、4、5的出现次数
            if (r === 3) selectedCounts[3]++;
            if (r === 4) selectedCounts[4]++;
            if (r === 5) selectedCounts[5]++;
        });

        // 获取未选中的卡片索引
        const unselectedIndices = [];
        for (let i = 0; i < NORMAL_POOL.length; i++) {
            if (!selected.includes(i)) {
                unselectedIndices.push(i);
            }
        }

        // 统计原始池中3、4、5的出现次数
        const poolCounts = {
            3: NORMAL_POOL.filter(v => v === 3).length,
            4: NORMAL_POOL.filter(v => v === 4).length,
            5: NORMAL_POOL.filter(v => v === 5).length
        };

        // 跟踪未选中区域中各数字的放置情况
        const unselectedPlaced = {3: 0, 4: 0, 5: 0};

        // 按优先级处理5、4、3
        const priorityNumbers = [5, 4, 3];
        priorityNumbers.forEach(num => {
            // 如果原始池中有该数字，且选中的卡片中出现次数少于原始池中的次数
            if (poolCounts[num] > 0 && selectedCounts[num] < poolCounts[num]) {
                // 需要在未选中区域放置的数量
                const needToPlace = poolCounts[num] - selectedCounts[num];

                for (let i = 0; i < needToPlace && unselectedIndices.length > 0; i++) {
                    // 找出最大的未选中索引
                    const maxUnselectedIdx = Math.max(...unselectedIndices);
                    // 将数字放在最大的未选中索引位置
                    cards[maxUnselectedIdx].querySelector(".front").textContent = num;
                    unselectedPlaced[num]++;
                    // 从可用索引中移除这个位置
                    const indexToRemove = unselectedIndices.indexOf(maxUnselectedIdx);
                    if (indexToRemove > -1) {
                        unselectedIndices.splice(indexToRemove, 1);
                    }
                }
            }
        });

        // 为剩余的未选中卡片分配原始值（从高到低排序）
        const remainingValues = NORMAL_POOL
            .filter(v => {
                // 如果是3、4、5，且已经在未选中区域放置了足够的数量，则排除
                if ([3, 4, 5].includes(v)) {
                    return unselectedPlaced[v] < poolCounts[v];
                }
                return true;
            })
            .sort((a, b) => b - a); // 从高到低排序

        unselectedIndices.forEach((idx, i) => {
            if (i < remainingValues.length) {
                cards[idx].querySelector(".front").textContent = remainingValues[i];
            }
        });

        // 为选中的卡片分配随机结果
        selectedResults.forEach(({ idx, value }) => {
            cards[idx].querySelector(".front").textContent = value;
        });

        // 打开所有卡片
        cards.forEach(card => {
            card.classList.add("open");
        });
    }

    /* ===== 再抽一次 ===== */
    function resetGame() {
        fetchRemote();
    }

    /* ===== 拉取远程池 ===== */
    function fetchRemote() {
        fetch(API_URL, {
            method: "POST",
            headers: {"Content-Type":"application/x-www-form-urlencoded"},
            body: "pack=3"
        })
            .then(r=>r.json())
            .then(res=>{
                if (res.code === 0 && res.data.length) {
                    const d = res.data[0];
                    NORMAL_POOL = [d.p1,d.p2,d.p3,d.p4,d.p5,d.p6,d.p7,d.p8,d.p9];
                    HIT_CONF = {
                        1:d.rand1,2:d.rand2,3:d.rand3,4:d.rand4,5:d.rand5,
                        max:d.max_at,
                        lock:d.lock_at_max
                    };
                }
                buildCards();
            })
            .catch(()=>buildCards());
    }
</script>

</body>
</html>