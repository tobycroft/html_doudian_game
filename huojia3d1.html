<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>WebGL 盲盒货架 Demo</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #e0e0e0;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;            /* 确保在底层，但仍可交互 */
            pointer-events: auto;  /* 保证鼠标事件有效 */
        }
    </style>


    <style>
        /*body, html { margin:0; height:100%; overflow:hidden; font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial; background:#cfeaff; }*/
        #canvas-wrap { width:100%; height:100%; position:relative; }
        #overlayNote {
            position:absolute; left:12px; top:12px;
            background:rgba(255,255,255,0.85);
            padding:8px 10px;
            border-radius:6px;
            box-shadow:0 3px 10px rgba(0,0,0,0.08);
            font-size:13px;
        }

        /* 悬浮详情窗 */
        #detailPopup {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background: rgba(255,255,255,0.97);
            box-shadow: 0 12px 40px rgba(0,0,0,0.25);
            border-radius: 12px;
            width: 360px;
            max-width: 90%;
            opacity: 0;
            pointer-events: none;
            transition: all 0.25s ease;
            z-index: 10;
            padding: 16px;
        }
        #detailPopup.show {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scal e(1);
        }
        #detailPopup img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #eee;
        }
        #detailPopup h3 {
            margin: 6px 0;
            font-size: 18px;
            color: #333;
        }
        #detailPopup p {
            margin: 6px 0 12px;
            font-size: 14px;
            color: #555;
            line-height: 1.5;
        }
        #closeBtn {
            display:inline-block;
            padding:8px 14px;
            background:#1976d2;
            color:white;
            border-radius:6px;
            cursor:pointer;
            text-decoration:none;
        }
    </style>
</head>
<body>
<div id="canvas-wrap">
    <div id="overlayNote">鼠标左键拖动平移 · 滚轮缩放 · 点击盒子查看详情</div>
    <canvas id="c"></canvas>

    <!-- 悬浮详情框 -->
    <div id="detailPopup">
        <img id="detailImg" src="" alt="">
        <h3 id="detailTitle">标题</h3>
        <p id="detailContent">内容</p>
        <a id="closeBtn">关闭</a>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
    /* ---------- three.js 初始化 ---------- */
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 2000);
    camera.position.set(0, 8, 18);

    const controls = new THREE.OrbitControls(camera, canvas);
    controls.enableRotate = false; // 禁止旋转
    controls.enablePan = true;
    controls.screenSpacePanning = true;
    controls.enableZoom = true;
    controls.panSpeed = 0.5;

    controls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,      // 左键平移
        MIDDLE: THREE.MOUSE.DOLLY,  // 中键缩放
        RIGHT: null                  // 右键无动作
    };
    controls.update();



    const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.9);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    scene.add(sun);

    const textureLoader = new THREE.TextureLoader();
    scene.background = textureLoader.load('https://threejs.org/examples/textures/skybox/skyboxsun25degtest.png');
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x88cc88, roughness:1}));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    /* ---------- 构建货架与盲盒 ---------- */
    const shelf = {
        shelfWidth: 14, shelfDepth: 4, shelfThickness: 0.25,
        shelfSpacing: 5.0, // 原来的 2.5 * 2，提高一倍
        boxSize: {x:2.2, y:1.8, z:2.0},
        boxPaddingX:0.4
    };
    function buildShelf(levelCount){
        const poleW = 0.35;
        const poleGeo = new THREE.BoxGeometry(poleW, levelCount * shelf.shelfSpacing + 1.0, poleW);
        const poleMat = new THREE.MeshStandardMaterial({color:0x6a4f2a});
        const left = new THREE.Mesh(poleGeo,poleMat), right = new THREE.Mesh(poleGeo,poleMat);
        left.position.set(-shelf.shelfWidth/2 - poleW/2, (levelCount-1)*shelf.shelfSpacing/2 + 0.7, 0);
        right.position.set(shelf.shelfWidth/2 + poleW/2, (levelCount-1)*shelf.shelfSpacing/2 + 0.7, 0);
        scene.add(left,right);
        for(let i=0;i<levelCount;i++){
            const sy = i * shelf.shelfSpacing + 0.5;
            const plank = new THREE.Mesh(new THREE.BoxGeometry(shelf.shelfWidth, shelf.shelfThickness, shelf.shelfDepth),
                new THREE.MeshStandardMaterial({color:0x8d6e4f}));
            plank.position.set(0, sy, 0);
            scene.add(plank);
        }
    }

    const inputJSON = {
        "第一层":{
            "第一个":{"status":false,"is_show":true,"str":"盒子名称1","title":"标题1","content":"盒子1内容","img":"https://picsum.photos/600/400?random=1"},
            "第二个":{"status":true,"is_show":true,"str":"盒子名称2","title":"标题2","content":"盒子2内容","img":"https://picsum.photos/600/400?random=2"}
        },
        "第二层":{
            "第一个":{"status":false,"is_show":true,"str":"盒子名称3","title":"标题3","content":"盒子3内容","img":"https://picsum.photos/600/400?random=3"}
        }
    };
    const layers = Object.keys(inputJSON);
    buildShelf(layers.length);

    const boxesGroup = new THREE.Group(); scene.add(boxesGroup);

    function makeTextTexture(text,width=512,height=512){
        const canvas = document.createElement('canvas');
        canvas.width=width; canvas.height=height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle="#fff"; ctx.fillRect(0,0,width,height);
        ctx.fillStyle="#111"; ctx.font="48px sans-serif";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(text, width/2, height/2);
        return new THREE.CanvasTexture(canvas);
    }

    const boxSize = shelf.boxSize;
    layers.forEach((layerKey, layerIndex) => {
        const layerObj = inputJSON[layerKey];
        const slotKeys = Object.keys(layerObj);
        const count = slotKeys.length;
        const totalWidth = count * boxSize.x + (count - 1) * shelf.boxPaddingX;
        const startX = - totalWidth / 2 + boxSize.x / 2;
        const y = layerIndex * shelf.shelfSpacing + 0.5 + shelf.shelfThickness / 2 + boxSize.y / 2;

        slotKeys.forEach((slotKey, i) => {
            const d = layerObj[slotKey];
            const x = startX + i * (boxSize.x + shelf.boxPaddingX);
            const slot = new THREE.Group();
            slot.position.set(x, y, 0);

            if (!d.is_show) {
                boxesGroup.add(slot);
                return;
            }

            // ------------------ 盒子主体 ------------------
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(boxSize.x, boxSize.y, boxSize.z),
                new THREE.MeshStandardMaterial({ color: d.status ? 0xfff1c2 : 0xffffff })
            );
            body.castShadow = true;
            body.receiveShadow = true;
            slot.add(body);

            // ------------------ 盒子盖子 ------------------
            const lidGeo = new THREE.BoxGeometry(boxSize.x * 1.02, boxSize.y * 0.35, boxSize.z);
            const lidMat = new THREE.MeshStandardMaterial({ color: d.status ? 0xffe08a : 0xececec });
            const lidMesh = new THREE.Mesh(lidGeo, lidMat);
            lidMesh.castShadow = true;

            const lidPivot = new THREE.Group();

            // 设置 pivot 在盒子顶部后边缘
            lidPivot.position.set(0, boxSize.y / 2, -boxSize.z / 2);

            // lidMesh 相对于 pivot 向前偏移（这样旋转就像掀盖子）
            lidMesh.position.set(0, -lidGeo.parameters.height / 2, lidGeo.parameters.depth / 2);
            lidPivot.add(lidMesh);

            // 初始打开状态
            if (d.status) lidPivot.rotation.x = -Math.PI / 2.6;

            // ------------------ 正面文字 ------------------
            const frontTex = makeTextTexture(d.str);
            const faceMesh = new THREE.Mesh(
                new THREE.BoxGeometry(boxSize.x * 0.98, boxSize.y * 0.85, 0.05), // 厚度很小，贴前面
                new THREE.MeshStandardMaterial({ map: frontTex, transparent: true })
            );
            // 放在盒子正面
            faceMesh.position.set(0, 0, boxSize.z / 2 + 0.025);

            // ------------------ 添加到 slot ------------------
            slot.add(lidPivot, faceMesh);
            slot.userData = { data: d, parts: { lidPivot, body } };
            boxesGroup.add(slot);
        });
    });

    /* ---------- 点击交互 ---------- */
    const raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2();
    const clickState={animating:false};
    function onPointerDown(event){
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer,camera);
        const intersects = raycaster.intersectObjects(boxesGroup.children,true);
        for(const inter of intersects){
            let obj = inter.object;
            while(obj && !obj.userData.data) obj = obj.parent;
            if(obj && obj.userData.data){ handleSlotClick(obj); break; }
        }
    }
    function moveCameraToSlot(slot){
        const targetPos = slot.position.clone();
        const camPos = camera.position.clone();
        const startTarget = controls.target.clone();

        // 摄像机距离盒子的偏移，可以调整
        const offset = new THREE.Vector3(0, 2, 6); // 高2，前6
        const targetCamPos = targetPos.clone().add(offset);

        const duration = 600; // ms
        const startTime = performance.now();

        function step(t){
            const p = Math.min(1, (t - startTime)/duration);
            const ease = p<0.5 ? 2*p*p : -1 + (4-2*p)*p; // 简单 ease

            // 插值目标点
            controls.target.lerpVectors(startTarget, targetPos, ease);
            // 插值摄像机位置
            camera.position.lerpVectors(camPos, targetCamPos, ease);

            controls.update();

            if(p < 1) requestAnimationFrame(step);
        }

        requestAnimationFrame(step);
    }


    function handleSlotClick(slot){


        const d = slot.userData.data;
        if(clickState.animating) return;
        clickState.animating = true;
        const parts = slot.userData.parts;
        const targetOpen = !d.status;
        const from = {r: parts.lidPivot.rotation.x};
        const to = {r: targetOpen? -Math.PI/2.6 : 0};
        const start = performance.now();
        const dur = 400;
        function step(t){
            const p = Math.min(1, (t-start)/dur);
            const ease = p<0.5 ? 2*p*p : -1 + (4-2*p)*p;
            parts.lidPivot.rotation.x = from.r + (to.r - from.r)*ease;
            if(p<1) requestAnimationFrame(step);
            else {
                d.status = targetOpen;
                parts.body.material.color.set(targetOpen?0xfff1c2:0xffffff);
                if(targetOpen) showDetail(d);
                clickState.animating=false;
            }
        }
        if(targetOpen){
            moveCameraToSlot(slot);
            showDetail(d);
        }
        requestAnimationFrame(step);
    }

    /* ---------- 悬浮窗逻辑 ---------- */
    const popup = document.getElementById('detailPopup');
    const img = document.getElementById('detailImg');
    const title = document.getElementById('detailTitle');
    const content = document.getElementById('detailContent');
    const closeBtn = document.getElementById('closeBtn');

    function showDetail(d){
        img.src = d.img || '';
        title.textContent = d.title || d.str || '未命名盲盒';
        content.textContent = d.content || '';
        popup.classList.add('show');
    }
    closeBtn.onclick = ()=> popup.classList.remove('show');
    window.addEventListener('click', (e)=>{
        if(e.target === popup) popup.classList.remove('show');
    });

    /* ---------- 渲染循环 ---------- */
    function resizeRendererToDisplaySize(){
        const w = canvas.clientWidth, h = canvas.clientHeight;
        if(canvas.width !== w*devicePixelRatio || canvas.height !== h*devicePixelRatio){
            renderer.setSize(w,h,false);
            camera.aspect = w/h;
            camera.updateProjectionMatrix();
        }
    }
    function render(){
        resizeRendererToDisplaySize();
        renderer.render(scene,camera);
        requestAnimationFrame(render);
    }
    render();

    window.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('resize', ()=>renderer.setSize(canvas.clientWidth, canvas.clientHeight, false));
</script>
</body>
</html>
